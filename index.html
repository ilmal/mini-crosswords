<!DOCTYPE html>
<html lang="en-US">
<head>
  <title>Dont sue me pls</title>
  <link rel="icon" type="image/x-icon" href="icon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Helvetica Neue', Arial, sans-serif; }
    .grid {
      display: grid;
      grid-template-columns: repeat(5, 60px);
      grid-template-rows: repeat(5, 60px);
      border: 2px solid #1a1a1a;
      margin: 20px auto;
      width: fit-content;
      box-shadow: 0 4px 6px rgba(0,0,0,.1);
      background: white;
    }
    .cell {
      border: 1px solid #1a1a1a;
      position: relative;
      background-color: #ffffff;
      transition: background-color .15s;
    }
    .black { background-color: #1a1a1a; }
    .label {
      position: absolute; top: 2px; left: 4px;
      font-size: 12px; font-weight: 600; color: #1a1a1a;
      user-select: none; pointer-events: none;
    }
    input {
      width: 100%; height: 100%;
      text-align: center; font-size: 24px; font-weight: 600;
      border: none; text-transform: uppercase; background: transparent;
      caret-color: #111827; /* visible caret */
      cursor: text;
    }
    input:focus { outline: none; background-color: #e5f2ff; }
    .selected { background-color: #dbeafe !important; box-shadow: inset 0 0 0 2px #1d4ed8; }
    .highlight { background-color: #eff6ff !important; }
    .correct { background-color: #e7f5e8 !important; }
    .incorrect { background-color: #ffe6e8 !important; }
    .revealed { background-color: #fff7cc !important; font-weight: 700; }
    .clue { padding: 4px 8px; border-radius: 4px; transition: background-color .15s; }
    .clue-selected { background-color: #eef2f7; }
    .modal {
      display: none; position: fixed; inset: 0;
      background-color: rgba(0,0,0,.5); align-items: center; justify-content: center;
    }
    .modal-content {
      background-color: #ffffff; padding: 20px; border-radius: 12px; max-width: 420px; width: 92%;
      box-shadow: 0 10px 25px rgba(0,0,0,.15);
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">
  <h1 class="text-3xl font-bold text-gray-900 mb-2">Mini Crossword</h1>
  <p id="status" class="text-sm text-gray-600 mb-6">—</p>

  <div class="mb-4 w-full max-w-2xl">
    <label for="puzzle-select" class="block text-sm font-medium text-gray-700 mb-2">Select Puzzle</label>
    <select id="puzzle-select" class="w-full border rounded-lg p-2 bg-white shadow-sm focus:outline-none focus:ring-2 focus:ring-slate-400">
      <!-- Populated dynamically -->
    </select>
  </div>

  <div class="grid" id="grid" aria-label="Crossword grid" role="grid"></div>

  <div class="clues flex flex-col md:flex-row justify-between w-full max-w-2xl mt-4 gap-4">
    <div class="clue-list w-full md:w-[48%]">
      <h2 class="text-lg font-semibold text-gray-800 mb-2">Across</h2>
      <div id="across-clues" class="space-y-1"></div>
    </div>
    <div class="clue-list w-full md:w-[48%]">
      <h2 class="text-lg font-semibold text-gray-800 mb-2">Down</h2>
      <div id="down-clues" class="space-y-1"></div>
    </div>
  </div>

  <div class="mt-6 flex flex-wrap gap-2">
    <button id="check" class="px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Check</button>
    <button id="reveal" class="px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Reveal</button>
    <button id="unreveal" class="px-3 py-2 rounded-md border border-slate-200 bg-slate-50 text-slate-400 cursor-not-allowed" disabled>Unreveal</button>
    <button id="hint" class="px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Hint</button>
    <button id="reset" class="px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Reset</button>
  </div>

  <div id="hint-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="hint-title">
    <div class="modal-content">
      <h2 id="hint-title" class="text-xl font-bold text-gray-800 mb-4">Hint</h2>
      <p id="hint-text" class="text-gray-700"></p>
      <button id="close-hint" class="mt-4 w-full px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Close</button>
    </div>
  </div>

  <script>
    let currentPuzzle = null;
    let currentPuzzleFile = null; // << stores filename for cookies
    let selectedCell = null;
    let selectedClue = null;
    let isAcross = true;
    let isChecked = false;
    let isRevealed = false;

    // Timing + persistence
    let isCompleted = false;
    let elapsedMs = 0;        // accumulated time
    let lastTick = null;      // last time we updated elapsed
    let timerInterval = null; // periodic saver

    // ---- Cookie helpers ----
    function setCookie(name, value, days = 365) {
      const secure = location.protocol === 'https:' ? '; Secure' : '';
      document.cookie = `${name}=${encodeURIComponent(value)}; Max-Age=${days*24*60*60}; Path=/; SameSite=Lax${secure}`;
    }
    function getCookie(name) {
      const match = document.cookie.split('; ').find(row => row.startsWith(name + '='));
      return match ? match.split('=')[1] : null;
    }
    function setCookieJSON(name, obj, days = 365) { setCookie(name, JSON.stringify(obj), days); }
    function getCookieJSON(name) { const v = getCookie(name); if (!v) return null; try { return JSON.parse(decodeURIComponent(v)); } catch { return null; } }
    function deleteCookie(name) { document.cookie = `${name}=; Max-Age=0; Path=/; SameSite=Lax`; }

    // Namespacing
    const COOKIE_PREFIX = 'MC_';
    const COMPLETED_COOKIE = COOKIE_PREFIX + 'COMPLETED'; // map { [puzzleId]: { timeMs, completedAt, byReveal, title } }
    const LAST_PUZZLE_COOKIE = COOKIE_PREFIX + 'LAST';     // string (filename)
    function stateCookieName() { return COOKIE_PREFIX + 'STATE_' + getPuzzleId(); }

    function getPuzzleId() {
      // Use filename if available; fallback to publication date; else UID
      const pub = currentPuzzle?.body?.[0]?.publicationDate || '';
      if (currentPuzzleFile) return currentPuzzleFile.replace(/^.*\/(.*)$/,'$1');
      return pub || 'puzzle_' + (currentPuzzle?.body?.[0]?.clues?.length || Math.random().toString(36).slice(2));
    }

    function startTimer() {
      lastTick = Date.now();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (!isCompleted && !isRevealed) {
          // accumulate elapsed and save silently every 5s
          const now = Date.now();
          elapsedMs += (now - lastTick);
          lastTick = now;
          saveProgress(true);
        }
      }, 5000);
    }
    function stopTimer() { if (timerInterval) { clearInterval(timerInterval); timerInterval = null; } }

    function formatMs(ms) {
      const m = Math.floor(ms / 60000);
      const s = Math.floor((ms % 60000) / 1000);
      return `${m}:${String(s).padStart(2,'0')}`;
    }

    function collectLetters() {
      const map = {};
      const cells = currentPuzzle.body[0].cells;
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
          const idx = row * 5 + col;
          if (cells[idx].answer) {
            const input = getInputAt(row, col);
            map[idx] = (input?.value || '').toUpperCase();
          }
        }
      }
      return map;
    }
    function applyLetters(map) {
      if (!map) return;
      Object.keys(map).forEach(k => {
        const idx = parseInt(k);
        const row = Math.floor(idx / 5);
        const col = idx % 5;
        const input = getInputAt(row, col);
        if (input) input.value = map[k] || '';
      });
    }

    function saveProgress(silent = false) {
      // If a timer session is active, accumulate since last tick
      if (!isCompleted && lastTick !== null && !isRevealed) {
        const now = Date.now();
        elapsedMs += (now - lastTick);
        lastTick = now;
      }
      const payload = {
        letters: collectLetters(),
        isChecked, isRevealed,
        elapsedMs, completed: isCompleted
      };
      setCookieJSON(stateCookieName(), payload);
      if (!silent) console.debug('Saved progress', payload);
    }

    function restoreProgress() {
      const state = getCookieJSON(stateCookieName());
      if (state) {
        applyLetters(state.letters);
        elapsedMs = state.elapsedMs || 0;
        isCompleted = !!state.completed;
        if (state.isRevealed) {
          // Will also mark completed
          revealAnswers();
        } else {
          if (state.isChecked) toggleCheck();
          if (!isCompleted) {
            setStatus(`Resumed — elapsed ${formatMs(elapsedMs)}.`);
            startTimer();
          } else {
            setStatus(`Solved in ${formatMs(elapsedMs)}.`);
          }
        }
      } else {
        // fresh start
        elapsedMs = 0; isCompleted = false; isChecked = false; isRevealed = false;
        startTimer();
        saveProgress(true);
      }
    }

    function markCompleted(byReveal = false) {
      if (isCompleted) { saveProgress(true); return; }
      if (!isPuzzleSolved()) return;
      isCompleted = true;
      // finalize time
      const now = Date.now();
      if (lastTick) { elapsedMs += (now - lastTick); lastTick = now; }
      stopTimer();

      const id = getPuzzleId();
      const title = currentPuzzle?.body?.[0]?.publicationDate || id;
      const comp = getCookieJSON(COMPLETED_COOKIE) || {};
      if (!comp[id]) {
        comp[id] = { timeMs: elapsedMs, completedAt: new Date().toISOString(), byReveal: !!byReveal, title };
        setCookieJSON(COMPLETED_COOKIE, comp);
      }
      setStatus(`Solved in ${formatMs(elapsedMs)}${byReveal ? ' (revealed)' : ''}.`);
      saveProgress(true);
    }

    function isPuzzleSolved() {
      const cells = currentPuzzle.body[0].cells;
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
          const idx = row * 5 + col;
          const cellData = cells[idx];
          if (!cellData.answer) continue;
          const input = getInputAt(row, col);
          if (!input || input.value.toUpperCase() !== cellData.answer.toUpperCase()) return false;
        }
      }
      return true;
    }

    window.addEventListener('beforeunload', () => saveProgress(true));

    // ---- Data loading ----
    async function fetchPuzzleList() {
      try {
        const response = await fetch('puzzles/puzzle-list.json');
        if (!response.ok) throw new Error('Failed to fetch puzzle list');
        return await response.json();
      } catch (e) {
        console.error(e);
        return [];
      }
    }

    async function populatePuzzleDropdown() {
      const puzzleSelect = document.getElementById('puzzle-select');
      const puzzles = await fetchPuzzleList();
      puzzleSelect.innerHTML = '';
      if (puzzles.length === 0) {
        puzzleSelect.innerHTML = '<option>No puzzles available</option>';
        return;
      }
      puzzles.sort((a,b) => new Date(b.date) - new Date(a.date));
      puzzles.forEach(p => {
        const option = document.createElement('option');
        option.value = p.file;
        option.textContent = `Puzzle - ${p.date}`;
        puzzleSelect.appendChild(option);
      });

      const last = getCookie(LAST_PUZZLE_COOKIE);
      const defaultFile = last && puzzles.some(p => p.file === last) ? last : puzzles[0].file;
      puzzleSelect.value = defaultFile;
      await loadPuzzle(`puzzles/${defaultFile}`);
    }

    async function loadPuzzle(puzzleFile) {
      try {
        const res = await fetch(puzzleFile);
        if (!res.ok) throw new Error('Failed to fetch puzzle');
        currentPuzzle = await res.json();
        currentPuzzleFile = puzzleFile.replace(/^puzzles\//,'');
        setCookie(LAST_PUZZLE_COOKIE, currentPuzzleFile);
        renderPuzzle();
      } catch (e) {
        console.error('Error loading puzzle:', e);
        document.getElementById('grid').innerHTML = '<p class="p-4">Error loading puzzle.</p>';
      }
    }

    // ---- Rendering ----
    function renderPuzzle() {
      const grid = document.getElementById('grid');
      const acrossClues = document.getElementById('across-clues');
      const downClues = document.getElementById('down-clues');
      grid.innerHTML = '';
      acrossClues.innerHTML = '';
      downClues.innerHTML = '';

      // Title + status
      const pub = currentPuzzle.body[0].publicationDate || '';
      document.querySelector('h1').textContent = `Mini Crossword${pub ? ' – ' + pub : ''}`;
      setStatus('Click a cell to start. Type letters; arrows move; Space toggles direction; Backspace/Delete edits.');

      // Grid
      const cells = currentPuzzle.body[0].cells;
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
          const idx = row * 5 + col;
          const cellData = cells[idx];
          const div = document.createElement('div');
          div.className = 'cell';
          div.dataset.row = row;
          div.dataset.col = col;
          div.setAttribute('role', 'gridcell');

          if (!cellData.answer) {
            div.classList.add('black');
          } else {
            if (cellData.label) {
              const span = document.createElement('span');
              span.className = 'label';
              span.textContent = cellData.label;
              div.appendChild(span);
            }
            const input = document.createElement('input');
            input.type = 'text';
            input.maxLength = 1;
            input.id = `cell-${row}-${col}`;
            input.autocomplete = 'off';
            input.autocapitalize = 'none';
            input.spellcheck = false;
            input.setAttribute('aria-label', `Row ${row+1}, Column ${col+1}`);
            div.appendChild(input);
          }
          grid.appendChild(div);
        }
      }

      // Clues
      currentPuzzle.body[0].clueLists.forEach(list => {
        const container = list.name === 'Across' ? acrossClues : downClues;
        list.clues.forEach(clueIdx => {
          const clue = currentPuzzle.body[0].clues[clueIdx];
          const div = document.createElement('div');
          div.className = 'clue hover:bg-slate-50 cursor-pointer';
          div.dataset.clueIdx = clueIdx;
          div.innerHTML = `<strong>${clue.label}</strong>: ${clue.text[0].plain}`;
          container.appendChild(div);
        });
      });

      initializeInteractions();

      // initial buttons state
      document.getElementById('unreveal').disabled = true;
      document.getElementById('unreveal').classList.add('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');

      // Restore any saved progress for this puzzle
      restoreProgress();
    }

    // ---- Interactions & UX ----
    function initializeInteractions() {
      const inputs = document.querySelectorAll('input');

      inputs.forEach(input => {
        input.addEventListener('focus', e => {
          const row = parseInt(e.target.parentElement.dataset.row);
          const col = parseInt(e.target.parentElement.dataset.col);
          selectCell(row, col, /*toggleIfSame*/ false);
          // Select existing content for quick overwrite
          setTimeout(() => e.target.select(), 0);
        });

        // Handle typed letters here (single source of truth)
        input.addEventListener('input', e => {
          // Keep letters only, uppercase, single char
          const letter = (e.target.value || '').replace(/[^A-Za-z]/g, '').toUpperCase().slice(0,1);
          e.target.value = letter;

          if (letter.length === 1) {
            const next = getNextInput(e.target, isAcross);
            if (next) { next.focus(); }
          }
          // Autosave + check completion on each input
          saveProgress(true);
          if (isPuzzleSolved()) markCompleted(false);
        });

        // Smart paste (fills across/down)
        input.addEventListener('paste', e => {
          e.preventDefault();
          const text = (e.clipboardData.getData('text') || '')
            .toUpperCase()
            .replace(/[^A-Z]/g, '');
          if (!text) return;

          let cur = e.target;
          cur.value = text[0] || '';
          for (let i = 1; i < text.length; i++) {
            const nxt = getNextInput(cur, isAcross);
            if (!nxt) break;
            nxt.value = text[i];
            cur = nxt;
          }
          cur.focus();
          saveProgress(true);
          if (isPuzzleSolved()) markCompleted(false);
        });

        input.addEventListener('keydown', handleKeydown);
        input.addEventListener('click', handleCellClick);
      });

      document.querySelectorAll('.clue').forEach(clue => {
        clue.addEventListener('click', () => {
          const clueIdx = parseInt(clue.dataset.clueIdx);
          selectClue(clueIdx, /*focusFirst*/ true);
        });
      });

      document.getElementById('check').addEventListener('click', () => { toggleCheck(); if (isPuzzleSolved()) markCompleted(false); saveProgress(true); });
      document.getElementById('reveal').addEventListener('click', () => { revealAnswers(); /* markCompleted happens inside */ saveProgress(true); });
      document.getElementById('unreveal').addEventListener('click', () => { unrevealAnswers(); saveProgress(true); });
      document.getElementById('hint').addEventListener('click', showHint);
      document.getElementById('reset').addEventListener('click', () => { resetGrid(); saveProgress(true); });
      document.getElementById('close-hint').addEventListener('click', () => {
        document.getElementById('hint-modal').style.display = 'none';
      });
      document.getElementById('puzzle-select').addEventListener('change', (e) => {
        const file = e.target.value;
        setCookie(LAST_PUZZLE_COOKIE, file);
        loadPuzzle(`puzzles/${file}`);
      });
    }

    function setStatus(text) {
      document.getElementById('status').textContent = text;
    }

    function handleCellClick(e) {
      const input = e.target;
      const row = parseInt(input.parentElement.dataset.row);
      const col = parseInt(input.parentElement.dataset.col);
      // Clicking the same cell toggles direction
      const same = selectedCell && selectedCell.row === row && selectedCell.col === col;
      selectCell(row, col, same /*toggleIfSame*/);
    }

    function selectCell(row, col, toggleIfSame = false) {
      document.querySelectorAll('.selected, .highlight').forEach(el => {
        el.classList.remove('selected', 'highlight');
      });
      document.querySelectorAll('.clue-selected').forEach(el => el.classList.remove('clue-selected'));

      // Toggle direction if reselecting same cell
      if (toggleIfSame) isAcross = !isAcross;

      selectedCell = { row, col };
      const cell = getCell(row, col);
      if (!cell || cell.classList.contains('black')) return;

      cell.classList.add('selected');
      const idx = row * 5 + col;
      const cellData = currentPuzzle.body[0].cells[idx];
      if (!cellData.clues) return;

      const clueIdx = isAcross ? cellData.clues[0] : cellData.clues[1];
      selectClue(clueIdx);
      setStatus(`${isAcross ? 'Across' : 'Down'} – ${currentPuzzle.body[0].clues[clueIdx].label}`);
    }

    function selectClue(clueIdx, focusFirst = false) {
      selectedClue = clueIdx;
      const clue = currentPuzzle.body[0].clues[clueIdx];
      isAcross = clue.direction === 'Across';

      const clueEl = document.querySelector(`.clue[data-clue-idx="${clueIdx}"]`);
      if (clueEl) clueEl.classList.add('clue-selected');

      // highlight cells in clue
      clue.cells.forEach(cellIdx => {
        const row = Math.floor(cellIdx / 5);
        const col = cellIdx % 5;
        const cell = getCell(row, col);
        if (cell && !cell.classList.contains('black')) {
          // keep the actual selected cell distinct
          if (!(selectedCell && row === selectedCell.row && col === selectedCell.col)) {
            cell.classList.add('highlight');
          }
        }
      });

      if (focusFirst && clue.cells.length) {
        const r = Math.floor(clue.cells[0] / 5);
        const c = clue.cells[0] % 5;
        const firstInput = getInputAt(r, c);
        if (firstInput) firstInput.focus();
      }
    }

    function getCell(row, col) {
      return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    }
    function getInputAt(row, col) {
      return document.getElementById(`cell-${row}-${col}`);
    }

    function getNextInput(current, across) {
      let row = parseInt(current.parentElement.dataset.row);
      let col = parseInt(current.parentElement.dataset.col);

      do {
        if (across) { col++; }
        else { row++; }
        if (row > 4 || col > 4) return null;
        const next = getInputAt(row, col);
        if (next && !next.parentElement.classList.contains('black')) return next;
      } while (true);
    }

    function getPrevInput(current, across) {
      let row = parseInt(current.parentElement.dataset.row);
      let col = parseInt(current.parentElement.dataset.col);

      do {
        if (across) { col--; }
        else { row--; }
        if (row < 0 || col < 0) return null;
        const prev = getInputAt(row, col);
        if (prev && !prev.parentElement.classList.contains('black')) return prev;
      } while (true);
    }

    function handleKeydown(e) {
      const row = parseInt(e.target.parentElement.dataset.row);
      const col = parseInt(e.target.parentElement.dataset.col);
      let handled = false;

      switch (e.key) {
        case 'ArrowDown':
          isAcross = false;
          moveFocus(row + 1, col); handled = true; break;
        case 'ArrowUp':
          isAcross = false;
          moveFocus(row - 1, col); handled = true; break;
        case 'ArrowRight':
          isAcross = true;
          moveFocus(row, col + 1); handled = true; break;
        case 'ArrowLeft':
          isAcross = true;
          moveFocus(row, col - 1); handled = true; break;

        case 'Backspace':
          if (e.target.value) {
            e.target.value = '';
          } else {
            const prev = getPrevInput(e.target, isAcross);
            if (prev) { prev.value = ''; prev.focus(); }
          }
          handled = true; saveProgress(true); break;

        case 'Delete':
          e.target.value = '';
          handled = true; saveProgress(true); break;

        case 'Enter':
        case ' ':
          isAcross = !isAcross;
          selectCell(row, col);
          handled = true; break;

        default:
          // Do not preventDefault for letter keys; input handler will manage them.
          break;
      }

      if (handled) e.preventDefault();
    }

    function moveFocus(newRow, newCol) {
      if (newRow < 0 || newRow > 4 || newCol < 0 || newCol > 4) return;
      const next = getInputAt(newRow, newCol);
      if (next) next.focus();
    }

    // ---- Buttons ----
    function toggleCheck() {
      isChecked = !isChecked;
      const inputs = document.querySelectorAll('input');
      const btn = document.getElementById('check');

      if (isChecked) {
        inputs.forEach(input => {
          const cell = input.parentElement;
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          const idx = row * 5 + col;
          const correct = currentPuzzle.body[0].cells[idx].answer;
          if (input.value.toUpperCase() === String(correct).toUpperCase()) {
            cell.classList.add('correct'); cell.classList.remove('incorrect');
          } else if (input.value) {
            cell.classList.add('incorrect'); cell.classList.remove('correct');
          } else {
            cell.classList.remove('correct','incorrect');
          }
        });
        btn.textContent = 'Uncheck';
      } else {
        inputs.forEach(input => input.parentElement.classList.remove('correct','incorrect'));
        btn.textContent = 'Check';
      }
    }

    function revealAnswers() {
      if (isRevealed) return;
      isRevealed = true;
      document.querySelectorAll('input').forEach(input => {
        const cell = input.parentElement;
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const idx = row * 5 + col;
        const correct = currentPuzzle.body[0].cells[idx].answer;
        input.value = correct;
        cell.classList.add('revealed');
        cell.classList.remove('correct','incorrect');
      });
      isChecked = false;
      document.getElementById('check').textContent = 'Check';

      document.getElementById('reveal').disabled = true;
      document.getElementById('reveal').classList.add('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      document.getElementById('unreveal').disabled = false;
      document.getElementById('unreveal').classList.remove('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');

      // Recording completion (by reveal)
      if (isPuzzleSolved()) markCompleted(true);
    }

    function unrevealAnswers() {
      if (!isRevealed) return;
      isRevealed = false;
      document.querySelectorAll('input').forEach(input => {
        const cell = input.parentElement;
        if (!cell.classList.contains('correct') && !cell.classList.contains('incorrect')) {
          input.value = '';
        }
        cell.classList.remove('revealed');
      });
      document.getElementById('reveal').disabled = false;
      document.getElementById('reveal').classList.remove('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      document.getElementById('unreveal').disabled = true;
      document.getElementById('unreveal').classList.add('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      // Reset completion state if user unreveals
      isCompleted = false;
      startTimer();
      setStatus('Grid unrevealed. Continue solving…');
    }

    function showHint() {
      if (selectedClue === null || selectedClue === undefined) {
        alert('Please select a clue first.');
        return;
      }
      const clue = currentPuzzle.body[0].clues[selectedClue];
      const hintText = document.getElementById('hint-text');
      const hints = {
        0: 'This park is known for its stunning turquoise lakes.',
        1: 'Think about what you press in an elevator.',
        2: 'A common public transit option in these cities.',
        3: 'The main character in a movie about a cooking rodent.',
        4: 'A word from a famous biblical commandment.',
        5: 'A casual term for your best friend.',
        6: 'Something your phone might buzz for.',
        7: 'This artist has a smooth, jazzy voice.',
        8: 'A number from a famous Middle Eastern tale.',
        9: 'Might be a stray fry or napkin.'
      };
      hintText.textContent = hints[selectedClue] || clue?.hint || 'No hint available.';
      document.getElementById('hint-modal').style.display = 'flex';
    }

    function resetGrid() {
      document.querySelectorAll('input').forEach(input => {
        input.value = '';
        input.parentElement.classList.remove('correct','incorrect','revealed','selected','highlight');
      });
      document.querySelectorAll('.clue-selected').forEach(el => el.classList.remove('clue-selected'));
      selectedCell = null;
      selectedClue = null;
      isChecked = false;
      isRevealed = false;
      isCompleted = false;
      elapsedMs = 0;
      document.getElementById('check').textContent = 'Check';
      document.getElementById('reveal').disabled = false;
      document.getElementById('reveal').classList.remove('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      document.getElementById('unreveal').disabled = true;
      document.getElementById('unreveal').classList.add('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      setStatus('Grid reset. Click a cell to start.');
      deleteCookie(stateCookieName());
      startTimer();
    }

    // ---- Init ----
    populatePuzzleDropdown();
  </script>
</body>
</html>

