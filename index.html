<!DOCTYPE html>
<html lang="en-US">
<head>
  <title>Dont sue me pls</title>
  <link rel="icon" type="image/x-icon" href="icon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Helvetica Neue', Arial, sans-serif; }
    .grid {
      display: grid;
      grid-template-columns: repeat(5, 60px);
      grid-template-rows: repeat(5, 60px);
      border: 2px solid #1a1a1a;
      margin: 20px auto;
      width: fit-content;
      box-shadow: 0 4px 6px rgba(0,0,0,.1);
      background: white;
    }
    .cell {
      border: 1px solid #1a1a1a;
      position: relative;
      background-color: #ffffff;
      transition: background-color .15s;
    }
    .black { background-color: #1a1a1a; }
    .label {
      position: absolute; top: 2px; left: 4px;
      font-size: 12px; font-weight: 600; color: #1a1a1a;
      user-select: none; pointer-events: none;
    }
    input {
      width: 100%; height: 100%;
      text-align: center; font-size: 24px; font-weight: 600;
      border: none; text-transform: uppercase; background: transparent;
      caret-color: #111827; /* visible caret */
      cursor: text;
    }
    input:focus { outline: none; background-color: #e5f2ff; }
    .selected { background-color: #dbeafe !important; box-shadow: inset 0 0 0 2px #1d4ed8; }
    .highlight { background-color: #eff6ff !important; }
    .correct { background-color: #e7f5e8 !important; }
    .incorrect { background-color: #ffe6e8 !important; }
    .revealed { background-color: #fff7cc !important; font-weight: 700; }
    .clue { padding: 4px 8px; border-radius: 4px; transition: background-color .15s; }
    .clue-selected { background-color: #eef2f7; }
    .modal {
      display: none; position: fixed; inset: 0;
      background-color: rgba(0,0,0,.5); align-items: center; justify-content: center;
    }
    .modal-content {
      background-color: #ffffff; padding: 20px; border-radius: 12px; max-width: 420px; width: 92%;
      box-shadow: 0 10px 25px rgba(0,0,0,.15);
    }
    #puzzle-select {
      font-family: 'Helvetica Neue', Arial, sans-serif;
      font-weight: 500;
    }
    #puzzle-select option {
      padding: 8px 12px;
      font-weight: 500;
    }
    .puzzle-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      max-height: calc(100vh - 140px);
      overflow-y: auto;
      padding: 20px;
      background: transparent;
      border-radius: 0;
      border: none;
    }
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 500px; /* Increased width for better usability */
      height: 100vh;
      background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
      border-right: 2px solid #e2e8f0;
      box-shadow: 4px 0 20px rgba(0,0,0,0.1);
      transform: translateX(0);
      transition: transform 0.3s ease;
      z-index: 1000;
      display: flex;
      flex-direction: column;
    }
    .sidebar.collapsed {
      transform: translateX(-460px); /* Adjusted for new width */
    }
    .sidebar-header {
      padding: 24px 20px 20px;
      border-bottom: 2px solid #e2e8f0;
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    }
    .sidebar-header h2 {
      font-size: 24px; /* Larger header for better readability */
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 8px;
    }
    .sidebar-header p {
      font-size: 16px; /* Increased font size */
      color: #64748b;
    }
    .search-container {
      position: relative;
      margin-top: 20px; /* More spacing */
    }
    .search-input {
      width: 100%;
      padding: 12px 40px 12px 16px; /* Increased padding */
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 16px; /* Larger text */
      background: white;
      transition: all 0.3s ease;
      outline: none;
    }
    .search-input:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    .search-icon {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 18px; /* Slightly larger icon */
      color: #64748b;
      pointer-events: none;
    }
    .search-icon svg { width: 18px; height: 18px; display: block; }

    /* collapse icon SVG styling */
    #collapse-icon { color: #64748b; }
    #collapse-icon svg { width: 22px; height: 22px; display: block; transform-origin: center; }
    #collapse-icon svg path { transition: transform 0.25s ease, fill 0.25s ease; }
    .sidebar.collapsed #collapse-icon svg { transform: rotate(180deg); color: #475569; }
    .sidebar-content {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .collapse-btn {
      position: absolute;
      top: 24px;
      right: -60px; /* Adjusted for new width */
      width: 60px; /* Wider button */
      height: 60px; /* Taller button */
      background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
      border: 2px solid #e2e8f0;
      border-left: none;
      border-radius: 0 12px 12px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 4px 0 16px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
      font-size: 20px; /* Larger icon */
      color: #64748b;
    }
    .collapse-btn:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      color: #475569;
      box-shadow: 6px 0 20px rgba(0,0,0,0.15);
    }
    .main-content {
      margin-left: 500px; /* Adjusted for new sidebar width */
      transition: margin-left 0.3s ease;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    .main-content.expanded {
      margin-left: 40px;
    }
    .puzzle-card {
      min-height: 4rem;
      background: white;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px; /* Increased padding */
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      text-align: center; /* Center the text */
    }
    .puzzle-card:hover {
      border-color: #3b82f6;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.15);
      transform: translateY(-2px);
    }
    .puzzle-card.selected {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    }
    .puzzle-card.completed {
      background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
      border-color: #22c55e;
      box-shadow: 0 2px 12px rgba(34, 197, 94, 0.15);
    }
    .puzzle-card.in-progress {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border-color: #f59e0b;
      box-shadow: 0 2px 12px rgba(245, 158, 11, 0.15);
    }
    .puzzle-card .date {
      font-weight: 700;
      font-size: 18px; /* Larger text */
      color: #1f2937;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px; /* More spacing */
    }
    .puzzle-card .status {
      font-size: 14px; /* Larger text */
      color: #6b7280;
      display: flex;
      align-items: center;
      gap: 8px; /* More spacing */
      font-weight: 500;
    }
    .puzzle-card.completed .status {
      color: #059669;
    }
    .puzzle-card.in-progress .status {
      color: #d97706;
    }
    .status-icon {
      font-size: 18px; /* Larger icon */
    }
    .menu-toggle {
      display: none;
    }
    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
        transform: translateX(-100%);
      }
      .sidebar.collapsed {
        transform: translateX(-100%);
      }
      .sidebar:not(.collapsed) {
        transform: translateX(0);
      }
      .main-content {
        margin-left: 0;
      }
      .main-content.expanded {
        margin-left: 0;
      }
      .collapse-btn {
        display: none;
      }
      .menu-toggle {
        display: block;
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1001;
        background: white;
        border: 1px solid #e2e8f0;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
    }
  </style>
</head>
<body class="bg-gray-100">
  <!-- Sidebar -->
  <div id="sidebar" class="sidebar">
    <div class="sidebar-header">
      <h2 class="text-2xl font-bold text-gray-800 mb-4">Select Puzzle</h2>
      <p class="text-base text-gray-600 mb-4">Choose a crossword to solve</p>
      <div class="search-container">
        <input type="text" id="puzzle-search" placeholder="Search puzzles..." class="search-input">
        <span class="search-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M10 2a8 8 0 105.293 14.293l4.707 4.707 1.414-1.414-4.707-4.707A8 8 0 0010 2zm0 2a6 6 0 110 12 6 6 0 010-12z" />
          </svg>
        </span>
      </div>
    </div>
    <div class="sidebar-content">
      <div id="puzzle-menu" class="puzzle-grid">
        <!-- Populated dynamically -->
      </div>
    </div>
    <button id="collapse-btn" class="collapse-btn" title="Toggle sidebar" aria-label="Toggle sidebar">
      <span id="collapse-icon" aria-hidden="true">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          <path fill="currentColor" d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" />
        </svg>
      </span>
    </button>
  </div>

  <!-- Mobile menu toggle -->
  <button id="menu-toggle" class="menu-toggle px-3 py-2 text-sm bg-blue-500 text-white rounded-md">☰ Menu</button>

  <!-- Main content -->
  <div id="main-content" class="main-content">
    <h1 class="text-3xl font-bold text-gray-900 mb-2">Mini Crossword</h1>
    <p id="status" class="text-sm text-gray-600 mb-6">—</p>

    <div class="grid" id="grid" aria-label="Crossword grid" role="grid"></div>

    <div class="clues flex flex-col md:flex-row justify-between w-full max-w-2xl mt-4 gap-4">
      <div class="clue-list w-full md:w-[48%]">
        <h2 class="text-lg font-semibold text-gray-800 mb-2">Across</h2>
        <div id="across-clues" class="space-y-1"></div>
      </div>
      <div class="clue-list w-full md:w-[48%]">
        <h2 class="text-lg font-semibold text-gray-800 mb-2">Down</h2>
        <div id="down-clues" class="space-y-1"></div>
      </div>
    </div>

    <div class="mt-6 flex flex-wrap gap-2">
      <button id="check" class="px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Check</button>
      <button id="reveal" class="px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Reveal</button>
      <button id="unreveal" class="px-3 py-2 rounded-md border border-slate-200 bg-slate-50 text-slate-400 cursor-not-allowed" disabled>Unreveal</button>
      <button id="hint" class="px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Hint</button>
      <button id="reset" class="px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Reset</button>
    </div>

    <div id="hint-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="hint-title">
      <div class="modal-content">
        <h2 id="hint-title" class="text-xl font-bold text-gray-800 mb-4">Hint</h2>
        <p id="hint-text" class="text-gray-700"></p>
        <button id="close-hint" class="mt-4 w-full px-3 py-2 rounded-md border border-slate-300 bg-white text-slate-800 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-400">Close</button>
      </div>
    </div>
  </div>

  <script>
    let currentPuzzle = null;
    let currentPuzzleFile = null; // << stores filename for cookies
    let selectedCell = null;
    let selectedClue = null;
    let isAcross = true;
    let isChecked = false;
    let isRevealed = false;

    // Simple status tracking
    let isCompleted = false;

    // ---- Cookie helpers ----
    function setCookie(name, value, days = 365) {
      const secure = location.protocol === 'https:' ? '; Secure' : '';
      document.cookie = `${name}=${encodeURIComponent(value)}; Max-Age=${days*24*60*60}; Path=/; SameSite=Lax${secure}`;
    }
    function getCookie(name) {
      const match = document.cookie.split('; ').find(row => row.startsWith(name + '='));
      return match ? match.split('=')[1] : null;
    }
    function setCookieJSON(name, obj, days = 365) { setCookie(name, JSON.stringify(obj), days); }
    function getCookieJSON(name) { const v = getCookie(name); if (!v) return null; try { return JSON.parse(decodeURIComponent(v)); } catch { return null; } }
    function deleteCookie(name) { document.cookie = `${name}=; Max-Age=0; Path=/; SameSite=Lax`; }

    // Namespacing
    const COOKIE_PREFIX = 'MC_';
    const STATUS_COOKIE = COOKIE_PREFIX + 'STATUS'; // map { [puzzleId]: 'completed' | 'in-progress' }
    const LAST_PUZZLE_COOKIE = COOKIE_PREFIX + 'LAST';     // string (filename)
    function stateCookieName() { return COOKIE_PREFIX + 'STATE_' + getPuzzleId(); }

    function getPuzzleId() {
      // Use filename if available; fallback to publication date; else UID
      const pub = currentPuzzle?.body?.[0]?.publicationDate || '';
      if (currentPuzzleFile) return currentPuzzleFile.replace(/^.*\/(.*)$/,'$1');
      return pub || 'puzzle_' + (currentPuzzle?.body?.[0]?.clues?.length || Math.random().toString(36).slice(2));
    }

    function updatePuzzleStatus(status) {
      const puzzleId = getPuzzleId();
      const statusMap = getCookieJSON(STATUS_COOKIE) || {};
      if (status === null) {
        delete statusMap[puzzleId];
      } else {
        statusMap[puzzleId] = status;
      }
      setCookieJSON(STATUS_COOKIE, statusMap);
      updatePuzzleDropdown(); // Refresh the dropdown to show status
    }

    function collectLetters() {
      if (!currentPuzzle?.body?.[0]?.cells) return {};
      const map = {};
      const cells = currentPuzzle.body[0].cells;
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
          const idx = row * 5 + col;
          if (cells[idx]?.answer) {
            const input = getInputAt(row, col);
            map[idx] = (input?.value || '').toUpperCase();
          }
        }
      }
      return map;
    }
    
    function applyLetters(map) {
      if (!map) return;
      Object.keys(map).forEach(k => {
        const idx = parseInt(k);
        const row = Math.floor(idx / 5);
        const col = idx % 5;
        const input = getInputAt(row, col);
        if (input) input.value = map[k] || '';
      });
    }

    function saveProgress() {
      const payload = {
        letters: collectLetters(),
        isChecked, isRevealed,
        completed: isCompleted,
        userProgress: isRevealed ? collectUserProgress() : collectLetters() // Always save user progress
      };
      setCookieJSON(stateCookieName(), payload);
      
      // Update status
      if (isCompleted) {
        updatePuzzleStatus('completed');
      } else if (hasAnyProgress()) {
        updatePuzzleStatus('in-progress');
      }
    }

    function collectUserProgress() {
      if (!currentPuzzle?.body?.[0]?.cells) return {};
      // Collect only the letters that user actually typed (not revealed)
      const map = {};
      const cells = currentPuzzle.body[0].cells;
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
          const idx = row * 5 + col;
          if (cells[idx]?.answer) {
            const input = getInputAt(row, col);
            const cell = input.parentElement;
            // Only save if it's not revealed
            if (!cell.classList.contains('revealed')) {
              map[idx] = (input?.value || '').toUpperCase();
            }
          }
        }
      }
      return map;
    }

    function hasAnyProgress() {
      const letters = collectLetters();
      return Object.values(letters).some(letter => letter.length > 0);
    }

    function restoreProgress() {
      const state = getCookieJSON(stateCookieName());
      if (state) {
        applyLetters(state.letters);
        isCompleted = !!state.completed;
        isRevealed = !!state.isRevealed;
        
        if (state.isRevealed) {
          // Mark revealed cells properly
          const userProgress = state.userProgress || {};
          document.querySelectorAll('input').forEach(input => {
            const cell = input.parentElement;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const idx = row * 5 + col;
            
            // If this cell has a value but user didn't originally have it, mark as revealed
            if (input.value && (!userProgress[idx] || userProgress[idx] !== input.value)) {
              cell.classList.add('revealed');
            }
          });
          
          // Update button states
          document.getElementById('reveal').disabled = true;
          document.getElementById('reveal').classList.add('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
          document.getElementById('unreveal').disabled = false;
          document.getElementById('unreveal').classList.remove('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
        } else {
          if (state.isChecked) toggleCheck();
        }
        
        if (isCompleted) {
          setStatus('Completed ✓');
        } else if (hasAnyProgress()) {
          setStatus('In progress...');
        } else {
          setStatus('Click a cell to start. Type letters; arrows move; Space toggles direction; Backspace/Delete edits.');
        }
      } else {
        isCompleted = false; isChecked = false; isRevealed = false;
        setStatus('Click a cell to start. Type letters; arrows move; Space toggles direction; Backspace/Delete edits.');
      }
    }

    function markCompleted(byReveal = false) {
      if (isCompleted) return;
      if (!isPuzzleSolved()) return;
      isCompleted = true;
      setStatus(`Completed ✓${byReveal ? ' (revealed)' : ''}`);
      saveProgress();
    }

    function isPuzzleSolved() {
      if (!currentPuzzle?.body?.[0]?.cells) return false;
      const cells = currentPuzzle.body[0].cells;
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
          const idx = row * 5 + col;
          const cellData = cells[idx];
          if (!cellData?.answer) continue;
          const input = getInputAt(row, col);
          if (!input || input.value.toUpperCase() !== cellData.answer.toUpperCase()) return false;
        }
      }
      return true;
    }

    window.addEventListener('beforeunload', () => saveProgress());

    // ---- Data loading ----
    async function fetchPuzzleList() {
      try {
        const response = await fetch('puzzles/puzzle-list.json');
        if (!response.ok) throw new Error('Failed to fetch puzzle list');
        return await response.json();
      } catch (e) {
        console.error(e);
        return [];
      }
    }

    async function populatePuzzleDropdown() {
      const puzzleMenu = document.getElementById('puzzle-menu');
      const puzzles = await fetchPuzzleList();
      puzzleMenu.innerHTML = '';
      
      if (puzzles.length === 0) {
        puzzleMenu.innerHTML = '<div class="puzzle-card"><div class="date">No puzzles available</div></div>';
        return;
      }
      
      const statusMap = getCookieJSON(STATUS_COOKIE) || {};
      puzzles.sort((a,b) => new Date(b.date) - new Date(a.date));
      
      puzzles.forEach(p => {
        const card = document.createElement('div');
        card.className = 'puzzle-card';
        card.dataset.file = p.file;
        
        const status = statusMap[p.file];
        
        if (status === 'completed') {
          card.classList.add('completed');
        } else if (status === 'in-progress') {
          card.classList.add('in-progress');
        }
        
        card.innerHTML = `
          <div class="date">${p.date}</div>
        `;
        
        card.addEventListener('click', () => {
          // Remove selected from all cards
          document.querySelectorAll('.puzzle-card').forEach(c => c.classList.remove('selected'));
          // Add selected to clicked card
          card.classList.add('selected');
          // Load the puzzle
          setCookie(LAST_PUZZLE_COOKIE, p.file);
          loadPuzzle(`puzzles/${p.file}`);
        });
        
        puzzleMenu.appendChild(card);
      });

      const last = getCookie(LAST_PUZZLE_COOKIE);
      const defaultFile = last && puzzles.some(p => p.file === last) ? last : puzzles[0].file;
      
      // Select the default card
      const defaultCard = document.querySelector(`[data-file="${defaultFile}"]`);
      if (defaultCard) defaultCard.classList.add('selected');
      
      await loadPuzzle(`puzzles/${defaultFile}`);
    }

    function updatePuzzleDropdown() {
      const statusMap = getCookieJSON(STATUS_COOKIE) || {};
      
      document.querySelectorAll('.puzzle-card').forEach(card => {
        const file = card.dataset.file;
        const status = statusMap[file];
        
        // Reset classes
        card.classList.remove('completed', 'in-progress');
        
        let statusText = 'Not started';
        let statusIcon = '';
        
        if (status === 'completed') {
          card.classList.add('completed');
          statusText = 'Completed';
          statusIcon = '✅';
        } else if (status === 'in-progress') {
          card.classList.add('in-progress');
          statusText = 'In progress';
          statusIcon = '⏳';
        }
        
        // Update the status display
        const statusEl = card.querySelector('.status');
        if (statusEl) {
          statusEl.innerHTML = `
            <span class="status-icon">${statusIcon}</span>
            <span>${statusText}</span>
          `;
        }
      });
    }

    async function loadPuzzle(puzzleFile) {
      try {
        const res = await fetch(puzzleFile);
        if (!res.ok) throw new Error('Failed to fetch puzzle');
        currentPuzzle = await res.json();
        currentPuzzleFile = puzzleFile.replace(/^puzzles\//,'');
        setCookie(LAST_PUZZLE_COOKIE, currentPuzzleFile);
        renderPuzzle();
      } catch (e) {
        console.error('Error loading puzzle:', e);
        document.getElementById('grid').innerHTML = '<p class="p-4">Error loading puzzle.</p>';
      }
    }

    // ---- Rendering ----
    function renderPuzzle() {
      const grid = document.getElementById('grid');
      const acrossClues = document.getElementById('across-clues');
      const downClues = document.getElementById('down-clues');
      grid.innerHTML = '';
      acrossClues.innerHTML = '';
      downClues.innerHTML = '';

      // Title + status
      const pub = currentPuzzle.body[0].publicationDate || '';
      document.querySelector('h1').textContent = `Mini Crossword${pub ? ' – ' + pub : ''}`;
      setStatus('Click a cell to start. Type letters; arrows move; Space toggles direction; Backspace/Delete edits.');

      // Grid
      const cells = currentPuzzle.body[0].cells;
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
          const idx = row * 5 + col;
          const cellData = cells[idx];
          const div = document.createElement('div');
          div.className = 'cell';
          div.dataset.row = row;
          div.dataset.col = col;
          div.setAttribute('role', 'gridcell');

          if (!cellData.answer) {
            div.classList.add('black');
          } else {
            if (cellData.label) {
              const span = document.createElement('span');
              span.className = 'label';
              span.textContent = cellData.label;
              div.appendChild(span);
            }
            const input = document.createElement('input');
            input.type = 'text';
            input.maxLength = 1;
            input.id = `cell-${row}-${col}`;
            input.autocomplete = 'off';
            input.autocapitalize = 'none';
            input.spellcheck = false;
            input.setAttribute('aria-label', `Row ${row+1}, Column ${col+1}`);
            div.appendChild(input);
          }
          grid.appendChild(div);
        }
      }

      // Clues
      currentPuzzle.body[0].clueLists.forEach(list => {
        const container = list.name === 'Across' ? acrossClues : downClues;
        list.clues.forEach(clueIdx => {
          const clue = currentPuzzle.body[0].clues[clueIdx];
          const div = document.createElement('div');
          div.className = 'clue hover:bg-slate-50 cursor-pointer';
          div.dataset.clueIdx = clueIdx;
          div.innerHTML = `<strong>${clue.label}</strong>: ${clue.text[0].plain}`;
          container.appendChild(div);
        });
      });

      initializeInteractions();

      // initial buttons state
      document.getElementById('unreveal').disabled = true;
      document.getElementById('unreveal').classList.add('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');

      // Restore any saved progress for this puzzle
      restoreProgress();
    }

    // ---- Interactions & UX ----
    function initializeInteractions() {
      const inputs = document.querySelectorAll('input');

      inputs.forEach(input => {
        input.addEventListener('focus', e => {
          const row = parseInt(e.target.parentElement.dataset.row);
          const col = parseInt(e.target.parentElement.dataset.col);
          selectCell(row, col, /*toggleIfSame*/ false);
          // Select existing content for quick overwrite
          setTimeout(() => e.target.select(), 0);
        });

        // Handle typed letters here (single source of truth)
        input.addEventListener('input', e => {
          // Keep letters only, uppercase, single char
          const letter = (e.target.value || '').replace(/[^A-Za-z]/g, '').toUpperCase().slice(0,1);
          e.target.value = letter;

          if (letter.length === 1) {
            const next = getNextInput(e.target, isAcross);
            if (next) { next.focus(); }
          }
          // Autosave + check completion on each input
          saveProgress();
          if (isPuzzleSolved()) markCompleted(false);
        });

        // Smart paste (fills across/down)
        input.addEventListener('paste', e => {
          e.preventDefault();
          const text = (e.clipboardData.getData('text') || '')
            .toUpperCase()
            .replace(/[^A-Z]/g, '');
          if (!text) return;

          let cur = e.target;
          cur.value = text[0] || '';
          for (let i = 1; i < text.length; i++) {
            const nxt = getNextInput(cur, isAcross);
            if (!nxt) break;
            nxt.value = text[i];
            cur = nxt;
          }
          cur.focus();
          saveProgress();
          if (isPuzzleSolved()) markCompleted(false);
        });

        input.addEventListener('keydown', handleKeydown);
        input.addEventListener('click', handleCellClick);
      });

      document.querySelectorAll('.clue').forEach(clue => {
        clue.addEventListener('click', () => {
          const clueIdx = parseInt(clue.dataset.clueIdx);
          selectClue(clueIdx, /*focusFirst*/ true);
        });
      });

      document.getElementById('check').addEventListener('click', () => { toggleCheck(); if (isPuzzleSolved()) markCompleted(false); saveProgress(); });
      document.getElementById('reveal').addEventListener('click', () => { revealAnswers(); saveProgress(); });
      document.getElementById('unreveal').addEventListener('click', () => { unrevealAnswers(); saveProgress(); });
      document.getElementById('hint').addEventListener('click', showHint);
      document.getElementById('reset').addEventListener('click', () => { resetGrid(); });
      document.getElementById('close-hint').addEventListener('click', () => {
        document.getElementById('hint-modal').style.display = 'none';
      });
      
      // Sidebar controls
      document.getElementById('collapse-btn').addEventListener('click', () => {
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('main-content');
        
        sidebar.classList.toggle('collapsed');
        mainContent.classList.toggle('expanded');
      });
      
      // Mobile menu toggle
      document.getElementById('menu-toggle').addEventListener('click', () => {
        const sidebar = document.getElementById('sidebar');
        sidebar.classList.toggle('collapsed');
      });
    }

    function setStatus(text) {
      document.getElementById('status').textContent = text;
    }

    function handleCellClick(e) {
      const input = e.target;
      const row = parseInt(input.parentElement.dataset.row);
      const col = parseInt(input.parentElement.dataset.col);
      // Clicking the same cell toggles direction
      const same = selectedCell && selectedCell.row === row && selectedCell.col === col;
      selectCell(row, col, same /*toggleIfSame*/);
    }

    function selectCell(row, col, toggleIfSame = false) {
      document.querySelectorAll('.selected, .highlight').forEach(el => {
        el.classList.remove('selected', 'highlight');
      });
      document.querySelectorAll('.clue-selected').forEach(el => el.classList.remove('clue-selected'));

      // Toggle direction if reselecting same cell
      if (toggleIfSame) isAcross = !isAcross;

      selectedCell = { row, col };
      const cell = getCell(row, col);
      if (!cell || cell.classList.contains('black')) return;

      cell.classList.add('selected');
      const idx = row * 5 + col;
      const cellData = currentPuzzle.body[0].cells[idx];
      if (!cellData.clues) return;

      const clueIdx = isAcross ? cellData.clues[0] : cellData.clues[1];
      selectClue(clueIdx);
      setStatus(`${isAcross ? 'Across' : 'Down'} – ${currentPuzzle.body[0].clues[clueIdx].label}`);
    }

    function selectClue(clueIdx, focusFirst = false) {
      selectedClue = clueIdx;
      const clue = currentPuzzle.body[0].clues[clueIdx];
      isAcross = clue.direction === 'Across';

      const clueEl = document.querySelector(`.clue[data-clue-idx="${clueIdx}"]`);
      if (clueEl) clueEl.classList.add('clue-selected');

      // highlight cells in clue
      clue.cells.forEach(cellIdx => {
        const row = Math.floor(cellIdx / 5);
        const col = cellIdx % 5;
        const cell = getCell(row, col);
        if (cell && !cell.classList.contains('black')) {
          // keep the actual selected cell distinct
          if (!(selectedCell && row === selectedCell.row && col === selectedCell.col)) {
            cell.classList.add('highlight');
          }
        }
      });

      if (focusFirst && clue.cells.length) {
        const r = Math.floor(clue.cells[0] / 5);
        const c = clue.cells[0] % 5;
        const firstInput = getInputAt(r, c);
        if (firstInput) firstInput.focus();
      }
    }

    function getCell(row, col) {
      return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    }
    function getInputAt(row, col) {
      return document.getElementById(`cell-${row}-${col}`);
    }

    function getNextInput(current, across) {
      let row = parseInt(current.parentElement.dataset.row);
      let col = parseInt(current.parentElement.dataset.col);

      do {
        if (across) { col++; }
        else { row++; }
        if (row > 4 || col > 4) return null;
        const next = getInputAt(row, col);
        if (next && !next.parentElement.classList.contains('black')) return next;
      } while (true);
    }

    function getPrevInput(current, across) {
      let row = parseInt(current.parentElement.dataset.row);
      let col = parseInt(current.parentElement.dataset.col);

      do {
        if (across) { col--; }
        else { row--; }
        if (row < 0 || col < 0) return null;
        const prev = getInputAt(row, col);
        if (prev && !prev.parentElement.classList.contains('black')) return prev;
      } while (true);
    }

    function handleKeydown(e) {
      const row = parseInt(e.target.parentElement.dataset.row);
      const col = parseInt(e.target.parentElement.dataset.col);
      let handled = false;

      switch (e.key) {
        case 'ArrowDown':
          isAcross = false;
          moveFocus(row + 1, col); handled = true; break;
        case 'ArrowUp':
          isAcross = false;
          moveFocus(row - 1, col); handled = true; break;
        case 'ArrowRight':
          isAcross = true;
          moveFocus(row, col + 1); handled = true; break;
        case 'ArrowLeft':
          isAcross = true;
          moveFocus(row, col - 1); handled = true; break;

        case 'Backspace':
          if (e.target.value) {
            e.target.value = '';
          } else {
            const prev = getPrevInput(e.target, isAcross);
            if (prev) { prev.value = ''; prev.focus(); }
          }
          handled = true; saveProgress(); break;

        case 'Delete':
          e.target.value = '';
          handled = true; saveProgress(); break;

        case 'Enter':
        case ' ':
          isAcross = !isAcross;
          selectCell(row, col);
          handled = true; break;

        default:
          // Do not preventDefault for letter keys; input handler will manage them.
          break;
      }

      if (handled) e.preventDefault();
    }

    function moveFocus(newRow, newCol) {
      if (newRow < 0 || newRow > 4 || newCol < 0 || newCol > 4) return;
      const next = getInputAt(newRow, newCol);
      if (next) next.focus();
    }

    // ---- Buttons ----
    function toggleCheck() {
      isChecked = !isChecked;
      const inputs = document.querySelectorAll('input');
      const btn = document.getElementById('check');

      if (isChecked) {
        inputs.forEach(input => {
          const cell = input.parentElement;
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          const idx = row * 5 + col;
          const correct = currentPuzzle.body[0].cells[idx]?.answer;
          if (correct && input.value.toUpperCase() === String(correct).toUpperCase()) {
            cell.classList.add('correct'); cell.classList.remove('incorrect');
          } else if (input.value) {
            cell.classList.add('incorrect'); cell.classList.remove('correct');
          } else {
            cell.classList.remove('correct','incorrect');
          }
        });
        btn.textContent = 'Uncheck';
      } else {
        inputs.forEach(input => input.parentElement.classList.remove('correct','incorrect'));
        btn.textContent = 'Check';
      }
    }

    function revealAnswers() {
      if (isRevealed) return;
      
      // Save current user progress before revealing (BEFORE setting isRevealed)
      const userProgress = collectUserProgress();
      
      isRevealed = true;
      document.querySelectorAll('input').forEach(input => {
        const cell = input.parentElement;
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const idx = row * 5 + col;
        const correct = currentPuzzle.body[0].cells[idx]?.answer;
        
        // Only reveal empty cells or incorrect cells
        if (correct && (!input.value || input.value.toUpperCase() !== correct.toUpperCase())) {
          input.value = correct;
          cell.classList.add('revealed');
        }
        cell.classList.remove('correct','incorrect');
      });
      
      // Now save with the user progress included
      saveProgress();
      
      isChecked = false;
      document.getElementById('check').textContent = 'Check';

      document.getElementById('reveal').disabled = true;
      document.getElementById('reveal').classList.add('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      document.getElementById('unreveal').disabled = false;
      document.getElementById('unreveal').classList.remove('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');

      // Recording completion (by reveal)
      markCompleted(true);
    }

    function unrevealAnswers() {
      if (!isRevealed) return;
      isRevealed = false;
      
      // Get the saved user progress
      const state = getCookieJSON(stateCookieName());
      const userProgress = state?.userProgress || {};
      
      document.querySelectorAll('input').forEach(input => {
        const cell = input.parentElement;
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const idx = row * 5 + col;
        
        if (cell.classList.contains('revealed')) {
          // Restore user's original input if they had one
          input.value = userProgress[idx] || '';
          cell.classList.remove('revealed');
        }
        cell.classList.remove('correct','incorrect');
      });
      
      document.getElementById('reveal').disabled = false;
      document.getElementById('reveal').classList.remove('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      document.getElementById('unreveal').disabled = true;
      document.getElementById('unreveal').classList.add('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      
      // Reset completion state if user unreveals
      isCompleted = false;
      setStatus('Grid unrevealed. Continue solving…');
      saveProgress();
    }

    function showHint() {
      if (selectedClue === null || selectedClue === undefined) {
        alert('Please select a clue first.');
        return;
      }
      const clue = currentPuzzle.body[0].clues[selectedClue];
      const hintText = document.getElementById('hint-text');
      const hints = {
        0: 'This park is known for its stunning turquoise lakes.',
        1: 'Think about what you press in an elevator.',
        2: 'A common public transit option in these cities.',
        3: 'The main character in a movie about a cooking rodent.',
        4: 'A word from a famous biblical commandment.',
        5: 'A casual term for your best friend.',
        6: 'Something your phone might buzz for.',
        7: 'This artist has a smooth, jazzy voice.',
        8: 'A number from a famous Middle Eastern tale.',
        9: 'Might be a stray fry or napkin.'
      };
      hintText.textContent = hints[selectedClue] || clue?.hint || 'No hint available.';
      document.getElementById('hint-modal').style.display = 'flex';
    }

    function resetGrid() {
      document.querySelectorAll('input').forEach(input => {
        input.value = '';
        input.parentElement.classList.remove('correct','incorrect','revealed','selected','highlight');
      });
      document.querySelectorAll('.clue-selected').forEach(el => el.classList.remove('clue-selected'));
      selectedCell = null;
      selectedClue = null;
      isChecked = false;
      isRevealed = false;
      isCompleted = false;
      document.getElementById('check').textContent = 'Check';
      document.getElementById('reveal').disabled = false;
      document.getElementById('reveal').classList.remove('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      document.getElementById('unreveal').disabled = true;
      document.getElementById('unreveal').classList.add('text-slate-400','bg-slate-50','border-slate-200','cursor-not-allowed');
      setStatus('Grid reset. Click a cell to start.');
      deleteCookie(stateCookieName());
      updatePuzzleStatus(null); // Remove status for this puzzle
    }

    // ---- Init ----
    populatePuzzleDropdown();
  </script>
</body>
</html>